# SQL 특강 

SQL 언어 자체는 문법의 구조나 난이도 면에서 어려운 언어가 아니지만, SQL로 다루는 데이터 베이스라는 시스템 자체는 굉장히 복잡하게 설정이 되어있다.

문법 구조는 쉬우나, 그 데이터를 갖추고 운영하는 행위 자체는 굉장히 어렵다. 같은 SELECT 문을 쓰더라도 자료의 규모에 따라 운영이 굉장히 어렵다. 

문법구조를 어떻게 조합을 하느냐에 따라서도 속도의 차이도 발생하고 이런 구조를 조정하는 것을 튜닝이라고 한다.

튜닝을 하기 위해서는 DB의 데이터 구조를 알 필요가 있고, 구조를 알지 못하더라도 기본적으로 우리가 지켜야 할 기본적인 사항이 있다.

자료를 빠르게 가져오고 , 누군가의 요청에 따라 상황에 맞는 자료를 가져와야한다.

오픈소스로서 누군가가 만들어 주는 프로그램들이 있기 때문에 일반유저가 고도의 스킬이 없더라도 사용하기 용이하다.

고비용을 사용하지 않으면서도 오라클과 같은 시스템을 사용할 수 있는 대안책 들을 찾는 중이다.

같은 SELECT 문이라도 GROUP BY  에서 WHERE 을 쓰느냐, HAVING 을 쓰느냐에 따라서 속도의 차이가 엄청나게 난다.  그런 구조의 차이를 알고, 적절하게 수정하는 것을 ==튜닝== 이라고 한다.

## 인덱스 & 키 

https://velog.io/@impala/SQL-%ED%82%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4
https://m.blog.naver.com/dnjswls23/222026710074 참조

인덱스와 키의 존재로 검색의 속도는 굉장히 빨라지지만, '인덱스' '키'라는 개념을 생성 해 줘야 하기 때문에 그 만큼의 별도의 공간이 필요하게 된다. 또한 이것의 구성이 달라지면 색인테이블에 다시 저장해야되기 때문에 그만큼의 속도차이가 다시 발생하게 된다.

WHERE 나 JOIN등의 행위를 할때 인덱스 키를 사용하면 굉장히 빠르게 작업이 처리된다. 


>1. 우리는 자료를 검색하려고 할 때 우리는 고객의 이름으로 검색하는 일이 굉장히 많아요
	-  이름은 유니크한 값이 아니다. 어떻게 유니크 한 값을 찾아내서 그것을 조회할지 방법에 대해 고민하게 된다.  
### WHERE & JOIN 의 차이
https://blog.leocat.kr/notes/2017/07/28/sql-join-on-vs-where 참조 

### 조건문에서 GROUP BY HAVING 은 WHERE 에 비해 속도가 느리다.

### SUB QUERY

- 프로그램에서는 이런식으로 생각하자!
	-  작은 것을 먼저 만들고 큰 것으로 간다.

### 시간 
SQL 에서 의외로 시간을 관리하는 일은 잘 없다. 만약에 쓴다면
	EX) 고객센터를 운영중인데 어떤 특정 시간대에 특히나 고객의 요청이 많이 오더라 등.

일반적인 회사에서는 생각보다 시간단위로 계산이라는 것을 많이 하지 않는다. 

하지만 우리는 ==컴퓨터가 어떻게 시간을 표현하는가== 정도는 알아야한다.

>[!note] 컴퓨터에서 표현할 수 있는 최초의 날짜는
>1900-01-01 이다.  그 전의 날짜는 날짜로 취급 하지 않는다.
>	EX) 엑셀에 1900-01-01 과 1800-1-1 을 각각 다른셀에 타이핑 해보자.
>	1900-01-01 셀에 더하기를 365를 더하면 1900-12-31 이 된다.

## <span style="color:rgb(255, 102, 163)">정규화</span>

- 간단하게 말해서, 이상현상(삽입, 삭제, 수정시)을 없애기 위해서 최대한 테이블을 쪼갠다.

- 이론적으로 공부하게 되면 정규화와 관련된 작업이 어엄청나게 많다. 하지만 직접하라고 하면 할 수 있는 사람은 거의 드물고, 그것을 만들 일도 거의 없다. 
	- 왜냐하면 이 과정은 데이터를 처음 수집할때 포맷을 세팅하는 일이고, 그 작업을 수행하는 것은 최상위 권 사람들이 하는 행위라서 일반인은 접할 경우가 거의 없다.


### 데이터의 이상현상 개념

- 테이블을 하나로 놓았을 때 생길 수 밖에 없는 문제점
	- 우리는 최종적으로 보는 테이블을 보기 때문에 테이블이 하나만 존재 할 것이다 라고 막연히 생각해 왔으나, 실제로는 이미 많은 SELECT 와 WHERE 등의 과정을 거쳐서 보이는 것이다.
> -> 연계성이 있는 데이터 간에 같은 정보가 들어가야 하는데, 미스타이핑 등의 이류로 잘못된 데이터가 들어가도 알 수 없음.

$ 삽입 이상

- 데이터는 항상 무언가의 요청을 하면 하나의 ROW를 뽑아 낼 수 있는 KEY 가 필요하다.

$ 삭제 이상

-  내가 삭제를 원치 않는 데이터가 같이 삭제 되는 현상


- @  **클래스 별로 최대한 데이터를 쪼개서, 단독 테이블로 존재 하게 만들어라.**

### [ 1 정규화 ] 일대일 
- 학생은 한명의 멘토가 있고, 멘토는 한명의 학생만 멘토링한다.
![[일대일|800]]

### [ 2 정규화 ]일대다 또는 다대일 

[ 수강 ] - 한명의 학생은 한 개의 과목만 수강 가능함. 한과목은 여러명의 학생을 받을 수 있음
![[일대다 다대일|800]]

### [ 3 정규화 ]다대다 

- 해커톤 대회는 어느 월에나 열릴 수 있고, 담당자는 어느 월이나 담당할 수 있다. 

![[다대다|800]]

### [ 4 정규화 ] 


---
## 질의 모호성

- 데이터를 요청할 때, JOIN 한 테이블의 필드 명이 똑같거나 그런 경우, 값을 요청 했을 때, 
- 어떤 데이터를 가져 와야할지 모르는 모호함이 발생한다. 그 개념을 말한다.

---

데이터베이스 에서의 행 순서는 순서의 의미가 없다.